## Integration Test

In the `integration` subdir there are 2 tests that implement
higher and lower level sender/receiver that use mocks for
the actual SNS/SQS access. 
They also demonstrate how to use the primitives: the calls and their sequence.

## End to End Test

Terraform in the .terra directory creates a test SNS topic and an SQS queue subscribed
to it. It also creates a user with the policy that allows it to publish into the SNS
and read from the created SQS.

Update the values of AWS Region in .terra/variables.tf and docker-compose.yml to your region.

The tf output values need to be used in the environment variables docker compose reads.
Before running docker compose, execute:

```shell
export ACCESS_KEY= output "key_id value
export SECRET_ACCESS_KEY= output "secret_key_id" value
export SNS_TOPIC_ARN= output "sns_arn" value
export SQS_TOPIC_URL= output "sqs_url" value
export CONCURRENCY= number of threads that will publish into SNS
export TOTAL_MESSAGES= total number of random strings that the above threads will publish to SNS
```

Then cd test && docker compose up will bring up 2 containers  
that will communicate via SNS+SQS. The TOTAL_MESSAGES will be generated by the client container
and published into the SNS topic that terraform created. The client container will read from
that terraform created SQS.


There are 3 different senders to test (in their respective directories) and one receiver:

- client/fivebatchers - CONCURRENCY number of go routines each using its own batcher/topic
- client/threadsafety - CONCURRENCY number of go routines sharing a single batcher/topic
- client/lowlevel - using the lower level batcher interface (batching.New) instead of the higher level primitives

So, you would run each of them respectively as:

- docker compose up client-multibatcher server postgres pgclient
- docker compose up client-singlebatcher server postgres pgclient
- docker compose up client-lowlevel server postgres pgclient

The postgres services are for storing the test information and verification
at the end of the test. You can also use the pgclient service container to
run SQLs against the postgres service that has the tables with both
client generated/sent and server received messages